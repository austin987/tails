#!/bin/sh

set -e

echo "Set fixed GIDs and UIDs"

Debug_gids_and_uids () {
	for file in passwd group; do
		diff -Naur "/usr/share/tails/build/${file}" "/etc/${file}" >&2 || :
		echo >&2
		echo "Content of '/etc/${file}':" >&2
		cat "/etc/${file}" >&2
		echo >&2
	done
}

Change_uid () {
	NAME="$1"
	NEW="$2"
	OLD="$(getent passwd "$NAME" | awk -F ':' '{print $3}')"

	if [ -n "$OLD" ]; then
		echo "Changing UID for $NAME ($OLD -> $NEW)"
		if ! usermod --uid "$NEW" "$NAME"; then
			Debug_gids_and_uids
			exit 1
		fi
		# chown(1) and chgrp(1) clear the setuid and setgid bits;
		# let's preserve them.
		#
		# Using "-exec CMD +", find builds command lines incrementally,
		# before executing chown. Which is why the operation below is
		# not the "if a file has the setuid bit, then give it the setuid
		# bit" no-op, but rather "if a file had the setuid bit before
		# chown was run, then set it back".
		find / -wholename /proc -prune -o \( \
				\! -type l -uid "$OLD" \
				-exec chown "$NEW" '{}' + \
				\( \
					   -perm -6000 -exec chmod gu+s '{}' + \
					-o -perm -4000 -exec chmod u+s  '{}' + \
					-o -perm -2000 -exec chmod g+s  '{}' + \
				\) \
			\)
	fi
}

Change_gid () {
	NAME="$1"
	NEW="$2"
	OLD="$(getent group "$NAME" | awk -F ':' '{print $3}')"

	if [ -n "$OLD" ]; then
		echo "Changing GID for $NAME ($OLD -> $NEW)"
		if ! groupmod --gid "$NEW" "$NAME"; then
			Debug_gids_and_uids
			exit 1
		fi
		# See comments in Change_uid().
		find / -wholename /proc -prune -o \( \
				\! -type l -gid "$OLD" \
				-exec chgrp "$NEW" '{}' + \
				\( \
					   -perm -6000 -exec chmod gu+s '{}' + \
					-o -perm -4000 -exec chmod u+s  '{}' + \
					-o -perm -2000 -exec chmod g+s  '{}' + \
				\) \
			\)
	fi
}
