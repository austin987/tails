#!/usr/bin/env python3

import logging
import socket
import sys
import gettext
import subprocess
from pydbus import SessionBus, SystemBus
import os
from pam import pam
import time
import pwd

UI_FILE = "/usr/share/tails/screenlocker.ui"

import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GLib
gi.require_version('Gdk', '3.0')
from gi.repository import Gdk


_ = gettext.gettext
gettext.install("Tails")

logging.basicConfig(level=logging.DEBUG)

mainloop = GLib.MainLoop()


def lock_screen():
    # org.gnome.ScreenSaver.Lock() sometimes does not return, so we set a timeout of 5 seconds
    try:
        SessionBus().get("org.gnome.ScreenSaver").Lock(timeout=5)
    except Exception as e:
        logging.exception(e)
    finally:
        sys.exit()


class PasswordDialog(object):

    def on_cancel_clicked(self, button, data=None):
        sys.exit(1)

    def on_entry_changed(self, entry, data=None):
        if not self.entry1.get_text() or not self.entry2.get_text():
            self.ok_button.set_sensitive(False)
        elif self.entry1.get_text() == self.entry2.get_text():
            # Passwords match
            self.ok_button.set_sensitive(True)
            self.entry2.set_icon_from_icon_name(1, None)
        else:
            # Passwords don't match
            self.ok_button.set_sensitive(False)
            self.entry2.set_icon_from_stock(1, self.mismatch_icon)

    def on_ok_clicked(self, button, data=None):
        pw1 = self.entry1.get_text()
        pw2 = self.entry2.get_text()
        if not pw1 == pw2:
            return

        self.pw = pw1.encode('ascii')

        bus = SystemBus()
        object_path = bus.get("org.freedesktop.Accounts").FindUserById(os.getuid())
        user_object = bus.get("org.freedesktop.Accounts", object_path)
        # lock the screen once the 'Changed' signal was received
        user_object.Changed.connect(self.wait_until_password_set_and_lock_screen)

        p = subprocess.Popen("passwd", stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p.stdin.write(self.pw + b"\n")
        p.stdin.write(self.pw)
        p.stdin.flush()
        out, err = p.communicate()
        if p.returncode != 0:
            print("passwd stdout: %s" % out)
            print("passwd stderr: %s" % err)
            raise RuntimeError("passwd returned %r" % p.returncode)

        # We close the window here for the case that lock_screen does not return immediately,
        # otherwise it would look like the app is unresponsive
        self.window.close()

    def on_key_pressed(self, widget, event):
        if Gdk.keyval_name(event.keyval) == "Escape":
            sys.exit(1)

        if self.ok_button.get_sensitive() and Gdk.keyval_name(event.keyval) == "Return":
            self.ok_button.clicked()

    def wait_until_password_set_and_lock_screen(self):
        # TODO: Remove this once this is fixed: https://bugzilla.gnome.org/show_bug.cgi?id=761969
        p = pam()
        while not p.authenticate(pwd.getpwuid(os.getuid()).pw_name, self.pw):
            logging.debug("PAM not updated yet...")
            time.sleep(0.01)
        # We close the window here for the case that lock_screen does not return immediately,
        # otherwise it would look like the app is unresponsive
        self.window.close()
        GLib.idle_add(lock_screen)

    def run(self):
        self.window.show()

    def __init__(self):
        self.pw = None
        self.builder = Gtk.Builder()
        self.builder.add_from_file(UI_FILE)
        self.builder.connect_signals(self)
        self.ok_button = self.builder.get_object('button_ok')
        self.entry1 = self.builder.get_object('entry1')
        self.entry2 = self.builder.get_object('entry2')
        self.mismatch_icon = self.entry2.get_icon_stock(1)
        self.entry2.set_icon_from_icon_name(1, None)
        self.ok_button.set_sensitive(False)
        self.window = self.builder.get_object("window")
        self.window.set_title(_("Set a screen lock password"))


def get_lock():
    # Source: https://stackoverflow.com/a/7758075
    # Original author: https://stackoverflow.com/users/639295/aychedee
    # Without holding a reference to our socket somewhere it gets garbage
    # collected when the function exits
    get_lock._lock_socket = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
    get_lock._lock_socket.bind('\0' + 'tails-screen-locker')


def is_password_set():
    output = subprocess.check_output(["passwd", "--status"])
    return output.split()[1] == b"P"


def main():
    get_lock()
    if is_password_set():
        lock_screen()
        return

    dialog = PasswordDialog()
    GLib.idle_add(dialog.run)
    mainloop.run()


if __name__ == "__main__":
    main()
