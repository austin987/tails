Data persistence is a somewhat tricky topic in a Live system context,
especially one explicitely designed to avoid leaving any trace of
its use.

Some real-life usecases however require to setup some kind of
data persistence, which should then be carefully introduced
and supported.

[[!toc levels=3]]

Usecases
========

[[!tag todo/research]]

What could be made persistent?
------------------------------

It remains to determine which usecases are of interest for our users
and thus should be support. Here are some possible ones.

### User data

#### Persistent application-specific configurations

This might be relevant for the following applications:

- gpg/ssh/vpn/OTR keys/configurations
- certificates
- IM and MUA configurations (since these can take a several
  steps to setup which is annoying to redo for every amnesia
  session)
- Tor's data/cache for faster bootstrap with slow connections and
  better protections through more stable entry guards (/var/lib/tor)
- I2P data/cache/log directory (/var/lib/i2p)

Perhaps it would be possible to make a tool so that the user can
choose exactly what files/directories that should be persistent,
and when to update them? Whith such a general solution the above
things would not have to be implemented individually and could
be present as default suggestions in the tool.

Stuff we don't want to actively support making persistent:

- web browser addons (while we don't want to make it impossible to
  install addons, we think it's a really bad idea, and won't actively
  support it, since it partitions the Tails users anonymity set, thus
  having bad consequences both on people who do it *and* on others)

#### Persistent user data store

A persistent non-home data store for whatever random files the user
wants to have persistent.

#### Full /home persistence

All of /home is persistent. This is very convenient for users who
have complex configurations for certain applications, like IMs,
MUAs, gpg an the like.

On the other hand clueless users could do really bad configurations that would
persist and thus expose them even after a reboot.

Also Tails upgrades to configurations in $HOME would be pretty
difficult to apply without breaking the users own configuration.

Great care should be given to the potential leaks of web browser
cache and history, IM logs and similar applications and their
data, so that even if the /home is compromised, it should be
difficult for the attacker to tell what exact internet resources
and services have been used. Unless the user has explicitly
chosen to store such information (bookmarking a site, adding
someone to their contact list or address book, activated IM chat
logs etc.).

### System

#### Persistent application installations

If a user need some program
not present in amnesia per default it can be quite annoying to fetch
the apt information (which takes a lot of time over tor) and
download it (also slow), it could be nice to have a persistent
directory (or similar) where all .deb-files are installed at
boot time.

#### System wide persistence

This would give users fine-grained control of the system and
possibility to set it up exactly after their own expectations.

All the problems of a persistent /home applies but are amplified
to a system-wide scale, for instance

- users can also break the firewall-based Tor enforcement
- sensitive information will leak outside of /home, like to
  /tmp, /var/log etc.
- get a persistent virus or other malware
- Tails upgrades would be near-impossible without breaking stuff.

Persistence storage location
----------------------------

* Encrypted partition on a removable storage device.
* Encrypted archive file on a removable storage device.
* Use persistence without a persistence media: an encrypted persistent
  archive could be remotely stored on existing storage services.

Specifications
==============

Once a persistent volume is enabled, two operation modes should be
supported:

* read-write access: changes to persistent files are saved
* read-only access to **only** be able to *use* persistent files
  (e.g. a GnuPG keyring) without leaving any new trace.

Moreover:

* Tails should default to use a persistent store it can detect on
  removable media *in read-only mode*.
* Read-write access to a persistent data store must not be the
  default: it must require a voluntary user action such as choosing
  enabling a "with read-write persistent data" option in the boot
  menu.
* The persistent data must be stored using strong, well-known, Free
  Software, peer-reviewed encryption tools.
* Blacklist fixed storage devices from the search for persistent
  volumes. Rationale: preventing the risk of using a malicious persistent volume
  seems more important than supporting the rare "I want to store my
  persistent volume on a fixed hard-disk" use-case.
  - grml's patch against `live-initramfs` to optionally set all
    harddisk devices to read-only mode was applied upstream as
    `97846cf1b1a`; this option should probably be forcibly enabled
    when the users chooses to activate some kind of persistency from
    the boot menu.

Roadmap
=======

The first use cases that will be supported are:

* persistent application-specific configurations;
* persistent user data store.

Implementing one of these brings support for the other one more or
less for free.

This work can be split into two parts:

1. Backend: improve Debian Live tools so they are able to implement our
   specifications. This shall be done hand in hand with upstream so
   that we don't end up maintaining a forked `live-boot` indefinitely.
   Since the UI (persistence toggling, etc.) will take place in the
   [[tails-greeter|todo/TailsGreeter]] [[todo/boot_menu]], factoring
   bits out of `live-boot` and making these support being run at a
   later time of the boot process is crucial.
   Along the way our development [[git branches|git]] can be used both as a
   testbed for our changes, and as a show-room displaying progress on
   this front.

2. User interface:
 - make it easy to use such persistence features (i.e. without adding
   arguments to the kernel command line by hand);
 - make it easy to specify which bits are persistent.

Implementation
==============

Debian Live already supports several kinds of persistence, including
snapshots of selected files and persistence store automounting, both
at the `$HOME` and system-wide levels.

Encryption of the persistent volumes is supported using cryptsetup or
loop-aes.

Persistent application-specific configurations
----------------------------------------------

Neither home automounting nor `live-snapshot` currently fit the
application-specific configuration persistence use case. Both because
they are not finely grained enough and persist too much. The best path
to a usable implementation seems to improve `live-snapshot`; it seems
like a better starting point because it has an include list feature
(`/etc/live-snapshot.list`) and is kinder to USB sticks (think of
write wearing).

Tails will move most boot-time communication with the user to a
graphical [[todo/boot_menu]], [[replacing the GDM
greeter|todo/TailsGreeter]]. This implies our work on persistence
support shall at the end of the day allow live-snapshot to run this
late in the boot process, instead of run from live-boot as is
currently done.

**Note**: the following is the set of options that Debian Live needs
to support both their current functionality and our usecase(s). Tails
will pre-configure some of these in `/etc/live/` and/or
`/proc/cmdline`, and only a tiny subset of options will be made
available to users by the Tails [[todo/boot_menu]]).

What needs to be done (checked in live-boot 2.0~a16-1 due to working
offline with an outdated Git working copy):

- Add support for file deletion (e.g. by replacing cpio with rsync).
- Add a option to ignore non-removable devices when looking for a
  persistent volume. Implementation: support a
  `persistent-media={removable,usb-removable}` option similar to
  `live-media=`. Being worked on in our `3.x/feature/persistent-removable`
  branch.
- There is no way to enable the home-sn kind of persistence while
  disabling others. Interface would be:

  * `persistent=(directories|system)`
  * `persistent-storage=(file|filesystem)`
  * `persistent-method=(snapshot|overlay)`

  Notes:
  * file+overlay not supported.
  * current `persistent=nofiles` is the same as
    `persistent-storage=filesystem`
  * As long as every possible value for every persistence sub-option
    is unique, we could support `persistent=directories,file,snapshot`,
    at least to avoid too long kernel command-line.

- Compression? `persistent-compression=...`

- Add a read-only mode. Easy for `live-snapshot`, tricky but doable
  for `-rw` kind of persistence. Let's start with the snapshot method.
  Let's add a `persistent-rw=(true|false)` parameter.

- The persistence data search order is not well documented enough:
  live-sn and home-sn files are searched before accordingly labelled
  partitions. This is not critical but we should fix it along the way.

- The `persistent=cryptsetup` boot parameter is incompatible with
  `persistent=nofiles` which involves snapshot files are first
  searched on non-encrypted devices, then on encrypted ones. It
  probably should be made into a first-class independent parameter
  such as `persistent-encryption=cryptsetup`.
  `persistent-encryption=luks` would btw. be more correct and would
  allow adding support for plain dm-crypt mappings that are also setup
  with cryptsetup. Also, `persistent=cryptsetup` only makes
  persistence volume encryption best-effort, but not compulsory,
  contrary to what could be more intuitive and suited for our needs.
  => add `persistent-encryption=(none|luks|...)` option, forget the
  current `persistent=cryptsetup` useless mode of operation.

- The cryptsetup support is not able to deal with file-backed Luks
  snapshots. Do we need this? On the long run we would probably prefer
  supporting plain dm-crypt mappings hidden in files: something
  similar to the `live-media-offset` would be perfect; the UI side of
  it will be tricky if we want to ask the offset to the user;  this
  could happen either in the boot menu or by hooking a menu
  that would probably run from inside the initramfs, before
  `scripts/live` attempts to copy snapshots data. See
  [[todo/boot_menu]].

- The `do_snap_copy` sub-procedure calculates free memory but does not
  seem to check there is actually enough.

Full /home persistence
----------------------

**Beware!** We're not even sure we want to support this usecase at all
ever.

The "home automounting" flavor seems like a nice starting point to
implement full /home persistency but it needs to be extended a bit:

* support a read-only mode (e.g. using aufs or similar), e.g.
  using a "persistent-ro" boot parameter
* support enabling `$HOME` persistence while disabling full
  persistence

Both seem easy to implement and contribute to the upstream
`live-boot` (everything happens in `scripts/live`).

Remote persistence storage
--------------------------

When the persistence feature is enabled **and** no persistence media
is found locally, the user would be asked for a server address +
login, password + encryption passphrase. Possible remote storage
include:

 - IMAP
 - sftp
 - [Syncany](http://www.syncany.org/) (similar to Dropbox, but data is
   encrypted locally) supports many storage types, including IMAP
 - tahoe-lafs?

- Is there a Fuse IMAP filesystem? Other ways to fetch a given email?

> duplicity, an encrypted backup solution has an IMAP backend since
> version 5.0.7 (6.x is available in lenny-backports and squeeze). It is
> able to backup and restore from a folder available in an email
> account. One downside: it uses Python's imaplib which does know
> how to connect to IMAP server with SSL or StartTLS, but not how
> to verify X.509 certificates.

- Encryption: symmetric GnuPG, encfs, ecryptfs, file-backed Luks or
  dm-crypt?

Read-only mode
--------------

There are two main ways to support using a persistent store in
read-only mode:

* copy the persistent content at boot time to a filesystem location (aufs)
* merge the persistent volume with a "diff" branch on ramdisk using
  aufs, and mount the resultant device, so that the mountpoint is seen
  as writable by applications but no actual change is made on disk.

User interface
--------------

### at boot time

Choosing between various persistence modes calls for a more complex
(implementation-wise) boot menu. See [[todo/boot_menu]] and
[[todo/TailsGreeter]] for details.

### during runtime

XXX
